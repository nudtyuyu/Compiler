#include "codegen.hpp"

namespace backend{
    using RegId = RegManager::RegId;

    string CodeGen::code_gen(){
        string code;
        code += module_gen(module);
        return code;
    }

    string CodeGen::module_gen(Module *module){
        string code;
        string dataCode;
        string textCode;
        //clear last module's label record
        clearModuleRecord(module);
        //generate asmcode for all global values 
        dataCode += globaldata_gen();

        code += space + ".arch armv7ve " + endl;
        code += space + ".text " + endl;
        auto functions = module->getFunctions();
        //auto functions = module->functions;
        
        for(auto iter = functions->begin(); iter != functions->end(); ++iter){
            string name = iter->first;
            Function* func = iter->second;
            auto bblist = func->getBasicBlocks();
            if(bblist.empty()) continue;
            //generate asmcode for each function
            textCode += function_gen(func) + endl;
        }
        code += (dataCode + textCode + endl);
        return code;
    }

    string CodeGen::functionHead_gen(Function *func){
        string code;
        code += space + ".globl " + func->getName() + endl;
        code += space + ".p2align " + std::to_string(int_p2align) + endl;
        code += space + ".type " + func->getName() + ", %function" + endl;
        code += func->getName() + ":" + endl;
        return code;
    }
    /**
     * stack structure:
     * 
     * last function stack
     * --------------------------   <-- fp  point
     * callee preserved regs (include fp, sp, lr)
     * --------------------------
     * tempory variable(ir inst)
     * --------------------------
     * arg0,arg1,arg2,arg3(as tempory variable)
     * --------------------------    
     * dynamic stack(by AllocaInst)  ********
     * -------------------------- 
     * caller preserved regs
     * --------------------------
     * arg4 ~ argX
     * --------------------------    <-- sp point
     * next function stack
     * 
    */
    /**
     * prologue :
     *          preserve callee-saved register (lr, fp and other callee-saved regs)
     *          set new fp
     *          alloc stack space for local var/ args / return value.
     *          store args to stack
     * */
   string CodeGen::prologueCode_gen(Function *func){
        string code;
        /** 
         *code in here
        */
        return code;
   }

    /* epilogue : 
     *          free stack space
     *          restore sp
     *          restore used callee-saved register(lr, fp and other callee-saved regs)
     *          bx lr
    */
    string CodeGen::epilogueCode_gen(Function *func){
        string code;
        /** 
         *code in here
        */
        return code;
    }

    string CodeGen::function_gen(Function *func){
        curFunc = func;
        clearFunctionRecord(func);
        string bbCode;
        auto bbs = func->getBasicBlocks();
        for(auto iter = bbs.begin(); iter != bbs.end(); ++iter){
            auto bb = iter->get();
            bbCode += basicBlock_gen(bb);
        }
        string code;
        string funcHead = functionHead_gen(func);
        string prologueCode = prologueCode_gen(func);
        string epilogueCode = epilogueCode_gen(func);
        string literalPoolsCode = literalPoolsCode_gen(func);
        //
        code = funcHead + prologueCode  + bbCode + \
                    epilogueCode + literalPoolsCode;
        return code;
    }

    string CodeGen::basicBlock_gen(BasicBlock *bb){
        curBB = bb;
        string bbLabel = getBBLabel(bb);
        string code;
        code += bbLabel + ":" + endl;
        for(auto &instr : bb->getInstructions()){
            auto instrType = instr->getKind();
            code += instruction_gen(instr.get());
        }
        return code;
    }
    /**
     * RegId : binaryInst_gen returns RegId as its destination operand
     * code  : asmcode generated by binaryInst_gen
    */
    pair<RegId, string> CodeGen::binaryInst_gen(BinaryInst *bInst, RegId dstRegId){
        string code;
        /** 
         *code in here
        */
        return {dstRegId, code};
    }

    pair<RegId, string> CodeGen::unaryInst_gen(UnaryInst *uInst, RegId dstRegId){
        string code;
        /** 
         *code in here
        */
        return {dstRegId, code};
    }
    pair<RegId, string> 
    CodeGen::allocaInst_gen(AllocaInst *aInst, RegManager::RegId dstRegId){
        string code;
        /** 
         *code in here
        */
        return {dstRegId, code};
    }

    string CodeGen::storeInst_gen(StoreInst *stInst){
        string code;
        /** 
         *code in here
        */
        return code;
    }
    pair<RegId, string> 
    CodeGen::loadInst_gen(LoadInst  *ldInst, RegId dstRegId){
        string code;
        /** 
         *code in here
        */
        return {dstRegId, code};
    }
    string CodeGen::returnInst_gen(ReturnInst *retInst){
        string code;
        /** 
         *code in here
        */
        return code;
    }
    string CodeGen::uncondBrInst_gen(UncondBrInst *ubInst){
        string code;
        /** 
         *code in here
        */
        return code;
    }
    string CodeGen::condBrInst_gen(CondBrInst *cbInst){
        string code;
        /** 
         *code in here
        */
        return code;
    }
    pair<RegId, string> 
    CodeGen::callInst_gen(CallInst *callInst, RegId dstRegId){
        string code;
        /** 
         *code in here
        */
        return {dstRegId, code};
    }

    string CodeGen::instruction_gen(Instruction *instr)
    {
        string code;
        string unkName = instr->getName();
        RegManager::RegId dstRegId = RegManager::RNONE;
        auto instrType = instr->getKind();
        pair<RegId, string> tmp;
        switch (instrType)
        {
        //binary inst
        case Instruction::kAdd :
        case Instruction::kMul :
        case Instruction::kSub :
        case Instruction::kDiv :
        case Instruction::kRem :
        case Instruction::kAnd :
        case Instruction::kOr  :
        case Instruction::kICmpEQ :
    	case Instruction::kICmpNE :
    	case Instruction::kICmpLT :
    	case Instruction::kICmpGT :
    	case Instruction::kICmpLE :
    	case Instruction::kICmpGE :
    	case Instruction::kFAdd   :
    	case Instruction::kFSub   :
    	case Instruction::kFMul :
    	case Instruction::kFDiv :
   	    case Instruction::kFRem :
    	case Instruction::kFCmpEQ :
    	case Instruction::kFCmpNE :
    	case Instruction::kFCmpLT :
    	case Instruction::kFCmpGT :
        {
            BinaryInst *bInst = dynamic_cast<BinaryInst *>(instr);
            //registers are used only for instruction operation, consider use which register (any one that is free for use)
            tmp = binaryInst_gen(bInst, RegManager::RANY);
            code += tmp.second;
            dstRegId = tmp.first;
            break;
        }
        //Unary Inst
        case Instruction::kPos :
        case Instruction::kNeg :
    	case Instruction::kNot :
    	case Instruction::kFPos :
    	case Instruction::kFNeg :
    	case Instruction::kFtoI :
    	case Instruction::kIToF :
        {
        	UnaryInst *uInst = dynamic_cast<UnaryInst *>(instr);
        	tmp = unaryInst_gen(uInst,RegManager::RANY);
        	code+= tmp.second;
        	dstRegId = tmp.first;
        	break;
        }
        case Instruction::kLoad :
        {
            LoadInst *ldInst = dynamic_cast<LoadInst *>(instr);
            tmp = loadInst_gen(ldInst, RegManager::RANY);
            code += M_emitComment("load inst");
            code += tmp.second;
            dstRegId = tmp.first;
            break;
        }
        case Instruction::kStore :
        {
            StoreInst *stInst = dynamic_cast<StoreInst *>(instr);
            code += M_emitComment("store inst");
            code += storeInst_gen(stInst);
            return code;
            break;
        }
        case Instruction::kAlloca:
        {
            AllocaInst *aInst = dynamic_cast<AllocaInst *>(instr);
            tmp = allocaInst_gen(aInst, RegManager::RANY);
            code += M_emitComment("alloca inst");
            code += tmp.second;
            dstRegId = tmp.first;
            break;
        }
        case Instruction::kReturn:
        {
            ReturnInst *retInst = dynamic_cast<ReturnInst *>(instr);
            code += M_emitComment("return inst");
            code += returnInst_gen(retInst);
            return code;
            break;
        }
        case Instruction::kCall:
        {
            CallInst *cInst = dynamic_cast<CallInst *>(instr);
            auto tmp = callInst_gen(cInst, RegManager::RANY);
            code += tmp.second;
            dstRegId = tmp.first;
            if(dstRegId == RegManager::R0) return code;
            break;
        }
        case Instruction::kBr:
        {
            UncondBrInst *ubInst = dynamic_cast<UncondBrInst *>(instr);
            code += uncondBrInst_gen(ubInst);
            return code;
            break;
        }
        case Instruction::kCondBr:
        {
            CondBrInst *cbInst = dynamic_cast<CondBrInst *>(instr);
            code += condBrInst_gen(cbInst);
            return code;
            break;
        }
        default:
        {
            code += "ERROR CODE : instruction " + \
                unkName + " is not implementation" + endl;
            break;
        }
        }
        if(!instr->getType()->isVoid()){
            code += storeRegToStack_gen(dstRegId, instr);
            // regm.freeReg(dstRegId);//TODO : code in here.
        }
        return code;
    }
    //
    string CodeGen::globaldata_gen(){
        string asmCode;
        /** 
         *code in here
        */
        auto globalValues = module->getGlobalValues(); // get the list of the globalValue
        for(auto iter = globalValues->begin();iter!=globalValues->end();iter++)
        {
        	string name = iter->first;
        	GlobalValue* gb = iter->second;
        	auto NumDims = gb->getNumDims();
        	auto type = gb->getType();
        	int size = 4;
        	int allSpace = 0;
        	int i;
        	int ElementNum = 1;
        	for(i=0;i<NumDims;i++)
        	{
        		auto d = gb->getDimValue(i);
        		
        		ElementNum*=d;
        	}
        	allSpace= ElementNum*size;
        	/*if(i==0)
        	{
        		allSpace = size;
        	}*/
        	char ObjSpace[50];
        	sprintf(ObjSpace,"%d",allSpace);
        	asmCode += space + ".global  " + name + endl;
        	if(gb->IsConst())
        	{
        		asmCode += space + ".section " + space+".rodata" + endl;
        	}
        	else if(gb->IsBss())
        	{
        		asmCode += space + ".bss" + endl;
        	}
        	else if(gb->IsHalf())
        	{
        		;
        	}
        	else
        	{
        		asmCode += space + ".data" + endl;
        	}
        	asmCode+= space + ".align   " + "2" +endl;
        	asmCode+= space + ".type    " + name + ","+ " %object"+endl;
        	asmCode+= space + ".size    " + name + ", " + ObjSpace + endl;
        	asmCode+= name + ":" +endl;
        	auto initV = gb->init();
        	if(initV!=nullptr && !initV->isInitList())
        	{
        		auto initv = (ConstantValue*)initV;
        		if(type->isInt())
        		{
        			int number = initv->getInt();
        			char ObjValue[50];
        			sprintf(ObjValue,"%d",number);
        			asmCode+= space + ".word   " + ObjValue +endl;
        		}
        		// TODO float???
        		else if(type->isFloat())
        		{
        			float number = initv->getFloat();
        			//char *nump =(char*)malloc(sizeof(char));
        			void*nump = &number;
        			char bytes[4];
        			for(int ii=0;ii<4;ii++)
        			{
        				bytes[ii] = ((char*)nump)[ii];
        			}
        			//int *nump = (int*)malloc(sizeof(int));
        			//*nump = number;
        			char ObjValue[50];
        			//int *mynum = bytes;
        			void*mynum = bytes;
        			sprintf(ObjValue,"%d",*(int*)mynum);
        			asmCode+= space + ".word   " + ObjValue +endl;
        			
        		}
        	}
        	else if(initV==nullptr && gb->IsBss())
        	{
        		asmCode+= space + ".space   " + ObjSpace +endl;
        	}	
        	else
        	{
        		auto initv = (InitList*)initV;
        		int numZero;
        		for(int j=0;j<ElementNum;j++)
        		{
        			auto element = initv->getElement(j);
        			numZero = 0;
        			while(element->name=="0")
        			{
        				numZero++;
        				j++;
        				if(j>=ElementNum)
        					break;
        				element = initv->getElement(j);
        			}
        			if(numZero>0)
        			{
        				int zero = numZero*4;
        				char ZeroSpace[50];
        				sprintf(ZeroSpace,"%d",zero);
        				asmCode+= space + ".space   " + ZeroSpace + endl;
        				if(j<ElementNum)
        					asmCode+= space + ".word    " + element->name +endl;
        			}
        			else
        				asmCode+= space + ".word    " + element->name +endl;
        		}
        	}
        	
        }
        return asmCode;
    }

    string CodeGen::literalPoolsCode_gen(Function *func){
        string code;
        /** 
         *code in here
        */
        return code;
    }

}//namespace backend
